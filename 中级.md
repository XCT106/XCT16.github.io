

###ğŸ˜†çº¿æ€§è¡¨

#####ğŸ¥³é¡ºåºå­˜å‚¨

~~~c++
é€»è¾‘ä¸Šç›¸é‚»çš„ä¸¤ä¸ªå…ƒç´ åœ¨ç‰©ç†ä½ç½®ä¸Šä¹Ÿç›¸é‚»
~~~

~~~c++
#define  MaxSize 50             //å®šä¹‰çº¿æ€§è¡¨é•¿åº¦
	typedef struct {          
		ELemType data[MaxSize]; //é¡ºåºçš„å…ƒç´ 
		int len;                //é¡ºåºè¡¨çš„å½“å‰é•¿åº¦
	}SqList;                    //é¡ºåºè¡¨çš„ç±»å‹å®šä¹‰
~~~

~~~c++
//åŠ¨æ€åˆ†é…
#define  InitSize 100            //è¡¨é•¿åº¦çš„åˆå§‹å®šä¹‰
	typedef struct {          
		ElemType* data;          //æŒ‡ç¤ºåŠ¨æ€åˆ†é…æ•°ç»„çš„æŒ‡é’ˆ
		int MaxSize, length;     //æ•°ç»„çš„æœ€å¤§å®¹é‡å’Œå½“å‰ä¸ªæ•°
	}SeqList;                    //åŠ¨æ€åˆ†é…æ•°ç»„é¡ºåºè¡¨çš„ç±»å‹å®šä¹‰
	//Cçš„åˆå§‹åŠ¨æ€åˆ†é…è¯­å¥ï¼š
	L.data = (ElemType*)malloc(sizeof(ElemType) * InitSize);
	//C++çš„åˆå§‹åŠ¨æ€åˆ†é…è¯­å¥ï¼š
	L.data = new ElemType[InitSize];
~~~

~~~c++
#include<stdio.h>
#include<stdlib.h>
#define  MaxSize 50        
typedef int ElemType;
//é™æ€åˆ†é…
typedef struct {
	ElemType data[MaxSize];  //å®šä¹‰çš„æ•°ç»„ï¼Œç”¨æ¥å­˜å…ƒç´         
	int length;     //å½“å‰é¡ºåºè¡¨ä¸­æœ‰å¤šå°‘ä¸ªå…ƒç´ 
}SqList;   
//iä»£è¡¨æ’å…¥ä½ç½®ï¼Œä»1å¼€å§‹ï¼Œeè¦æ’å…¥çš„å…ƒç´ 
bool ListInsert(SqList& L, int i, ElemType e)
{
	if (i<1 || i>L.length + 1)//åˆ¤æ–­è¦æ’å…¥çš„ä½ç½®æ˜¯å¦åˆæ³•
	{
		return false;
	}
	if (L.length >= MaxSize)//è¶…å‡ºç©ºé—´
	{
		return false;
	}
	for (int j = L.length; j >= i; j--)//ç§»åŠ¨é¡ºåºè¡¨ä¸­çš„å…ƒç´ 
	{
		L.data[j] = L.data[j - 1];
	}
	L.data[i - 1] = e;//æ•°ç»„ä¸‹æ ‡ä»é›¶å¼€å§‹ï¼Œæ’å…¥ç¬¬ä¸€ä¸ªä½ç½®ï¼Œè®¿é—®çš„ä¸‹æ ‡ä¸º0
	L.length++;
	return true;
}
//æ‰“å°é¡ºåºè¡¨å…ƒç´ 
void PrintList(SqList& L)
{
	for (int i = 0; i < L.length; i++)
	{
		printf("%3d", L.data[i]);//è¦æ±‚æ‰€æœ‰å…ƒç´ æ‰“å°åˆ°ä¸€æ’
	}
	printf("\n");
}
//åˆ é™¤ä½¿ç”¨å…ƒç´ eçš„å¼•ç”¨çš„ç›®çš„æ˜¯æ‹¿å‡ºå¯¹åº”çš„å€¼
bool ListDelete(SqList& L, int i, ElemType& e)
{
	if (i<1 || i>L.length)//åˆ¤æ–­åˆ é™¤çš„ä½ç½®æ˜¯å¦åˆæ³•
	{
		return false;
	}
	if (L.length == 0)//é¡ºåºè¡¨ä¸­æ²¡æœ‰å…ƒç´ ï¼Œæ— éœ€åˆ é™¤
	{
		return false;
	}
	e = L.data[i - 1];//è·å–é¡ºåºè¡¨ä¸­å¯¹åº”çš„å…ƒç´ ï¼Œèµ‹å€¼ç»™e
	for (int j = i; j < L.length; j++)
	{
		L.data[j - 1] = L.data[j];
	}
	L.length--;//åˆ é™¤ä¸€ä¸ªå…ƒç´ ï¼Œé¡ºåºè¡¨é•¿åº¦å‡1
	return true;
}
//æŸ¥æ‰¾æˆåŠŸï¼Œè¿”å›ä½ç½®ï¼Œä½ç½®ä»1å¼€å§‹ï¼ŒæŸ¥æ‰¾å¤±è´¥ï¼Œè¿”å›0
int LocateElem(SqList L, ElemType e)
{
	int i;
	for(i=0;i<L.length;i++)
		if (L.data[i] == e)
		{
			return i + 1;//åŠ 1å°±æ˜¯å…ƒç´ åœ¨é¡ºåºè¡¨ä¸­çš„ä½ç½®
		}
	return 0;
}
int main()
{
	SqList L;//é¡ºåºçš„åç§°
	bool ret;//æŸ¥çœ‹è¿”å›å€¼
	ElemType del;//ç”¨æ¥å­˜è¦åˆ é™¤çš„å…ƒç´ 
	//é¦–å…ˆæ‰‹åŠ¨åœ¨é¡ºåºè¡¨ä¸­èµ‹å€¼
	L.data[0] = 1;
	L.data[1] = 2;
	L.data[2] = 3;
	L.length = 3;//æ€»è®¡ä¸‰ä¸ªå…ƒç´ 
	ret = ListInsert(L, 2, 60);//å¾€ç¬¬äºŒä¸ªå…ƒç´ æ’å…¥60
	if (ret)
	{
		printf("æ’å…¥æˆåŠŸ\n");
		PrintList(L);//æ‰“å°æˆåŠŸåçš„é¡ºåºè¡¨
	}
	else {
		printf("æ’å…¥å¤±è´¥\n");
	}
	ret = ListDelete(L, 1, del);//åˆ é™¤ç¬¬ä¸€ä¸ªä½ç½®çš„å…ƒç´ ï¼Œå¹¶æŠŠå…ƒç´ å€¼è¾“å‡º
	if (ret)
	{
		printf("åˆ é™¤æˆåŠŸ\n");
		printf("åˆ é™¤çš„å…ƒç´ å€¼ä¸º%d\n",del);
		PrintList(L);//æ‰“å°æˆåŠŸåçš„é¡ºåºè¡¨
	}
	else {
		printf("åˆ é™¤å¤±è´¥\n");
	}
	int num = LocateElem(L, 60);
	if (ret)
	{
		printf("æŸ¥æ‰¾æˆåŠŸ\n");
		printf("å…ƒç´ ä½ç½®ä¸º%d\n", num);
		PrintList(L);//æ‰“å°æˆåŠŸåçš„é¡ºåºè¡¨
	}
	else {
		printf("æŸ¥æ‰¾å¤±è´¥\n");
	}
	return 0;
}
~~~

#####ğŸ˜Šé“¾å¼å­˜å‚¨

###### ğŸ˜€å•é“¾è¡¨

~~~c++
å•é“¾è¡¨ç»“ç‚¹çš„å®šä¹‰
typedef struct LNode {  //å•é“¾è¡¨èŠ‚ç‚¹ç±»å‹
	ElemType data;      //æ•°æ®åŸŸ
	struct LNode* next; //æŒ‡é’ˆåŸŸ
}LNode,*LinkList;   //LinkListç›¸å½“äº
~~~

~~~c++
#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
#include<stdlib.h>
typedef int ElemType;
typedef struct LNode {  //å•é“¾è¡¨èŠ‚ç‚¹ç±»å‹
	ElemType data;      //æ•°æ®åŸŸ
	struct LNode *next; //æŒ‡é’ˆåŸŸ,æŒ‡å‘ä¸‹ä¸€ä¸ªç»“ç‚¹
}LNode,*LinkList;
//å¤´æ’æ³•æ–°å»ºé“¾è¡¨
LinkList CreatList1(LinkList &L)//list_head_insert
{
	LNode* s;
	int x;
	L = (LinkList)malloc(sizeof(LNode));//å¸¦å¤´ç»“ç‚¹çš„é“¾è¡¨
	L->next = NULL;//L->dataé‡Œè¾¹æ²¡æ”¾ä¸œè¥¿
	scanf("%d", &x);//ä»æ ‡å‡†è¾“å…¥è¯»å–æ•°æ®
	//3 4 5 6 7 9999
	while (x!=9999)
	{
		s = (LNode*)malloc(sizeof(LNode));//å¸¦å¤´ç»“ç‚¹çš„é“¾è¡¨
		s->data = x;//æŠŠè¯»å–åˆ°çš„å€¼ï¼Œç»™ç©ºé—´ä¸­çš„dataæˆå‘˜
		s->next = L->next;//è®©æ–°ç»“ç‚¹çš„nextæŒ‡é’ˆæŒ‡å‘åŸæœ‰çš„å¤´éƒ¨ç»“ç‚¹
		L->next = s;//è®©sä½œä¸ºç¬¬ä¸€ä¸ªå…ƒç´ 
		scanf("%d", &x);//è¯»å–
	}
	return L;
}
//å°¾æ’æ³•æ–°å»ºé“¾è¡¨
LinkList CreatList2(LinkList& L)
{
	int x;
	L = (LinkList)malloc(sizeof(LNode));//å¸¦å¤´ç»“ç‚¹çš„é“¾è¡¨
	LNode* s, * r = L;//LinkList s,r=L;ä¹Ÿå¯ä»¥ï¼Œrä»£è¡¨é“¾è¡¨è¡¨å°¾ç»“ç‚¹ï¼ŒæŒ‡å‘é“¾è¡¨å°¾éƒ¨
	//3 4 5 6 7 999
	scanf("%d", &x);
	while (x != 9999)
	{
		s = (LNode*)malloc(sizeof(LNode));//å¸¦å¤´ç»“ç‚¹çš„é“¾è¡¨
		s->data = x;//æŠŠè¯»å–åˆ°çš„å€¼ï¼Œç»™ç©ºé—´ä¸­çš„dataæˆå‘˜
		r->next = s;//è®©å°¾éƒ¨ç»“ç‚¹æŒ‡å‘æ–°ç»“ç‚¹
		r = s;//ræŒ‡å‘æ–°çš„è¡¨å°¾ç»“ç‚¹
		scanf("%d", &x);//è¯»å–
	}
	r->next = NULL;//å°¾ç»“ç‚¹çš„nextæŒ‡é’ˆèµ‹å€¼ä¸ºNULL
	return L;
}
void PrintList(LinkList L)
{
	L = L->next;
	while (L != NULL)
	{
		printf("%3d", L->data);
		L = L->next;
	}
	printf("\n");
}
//æŸ¥æ‰¾ç¬¬å‡ ä¸ªç»“ç‚¹çš„å€¼
LNode* GetElem(LinkList L, int i)
{
	int j = 1;
	LNode* p = L->next;
	if (i == 0)
	{
		return L;//iæ˜¯é›¶å°±è¿”å›å¤´ç»“ç‚¹
	}
	if (i < 1)
	{
		return NULL;//iæ˜¯è´Ÿå€¼å°±è¿”å›ç©º
	}
	while (p && j < i)
	{
		p = p->next;
		j++;
	}
	return p;
}
//æŒ‰å€¼æŸ¥è¯¢
LinkList LocateElem(LinkList L, ElemType e)
{
	LinkList p = L->next;
	while (p!=NULL&&p->data!=e)
	{
		p = p->next;
	}
	return p;
}
//æ–°ç»“ç‚¹æ’å…¥ç¬¬iä¸ªä½ç½®
bool ListFrontInsert(LinkList L,int i,ElemType e)
{
	LinkList p = GetElem(L, i - 1);
	if (NULL == p)
	{
		return false;//iä¸å¯¹
	}
	LinkList s = (LNode*)malloc(sizeof(LNode));//ä¸ºæ–°æ’å…¥çš„ç»“ç‚¹ç”³è¯·ç©ºé—´
	s->data = e;
	s->next = p->next;
	p->next = s;
	return true;
}
//åˆ é™¤ç»“ç‚¹
bool ListDelete(LinkList L,int i)
{
	LinkList p = GetElem(L, i - 1);//æŸ¥æ‰¾åˆ é™¤ä½ç½®çš„å‰é©±ç»“ç‚¹
	if (NULL == p)
	{
		return false;
	}
	LinkList q = p->next;
	p->next = q->next;
	free(q);
	q = NULL;//ä¸ºäº†é¿å…é‡æŒ‡é’ˆ
	return true;
}
int main()
{
	LinkList L;//é“¾è¡¨å¤´ï¼Œæ˜¯ç»“æ„ä½“æŒ‡é’ˆç±»å‹
	CreatList1(L);//è¾“å…¥æ•°æ®å¯ä»¥ä¸º3 4 5 6 7 9999
	PrintList(L);//é“¾è¡¨æ‰“å°
	CreatList2(L);
	PrintList(L);
	LinkList search;//ç”¨æ¥å­˜å‚¨æ‹¿åˆ°çš„æŸä¸€ä¸ªç»“ç‚¹
	search = GetElem(L, 2);//æŸ¥æ‰¾é“¾è¡¨ç¬¬äºŒä¸ªä½ç½®çš„å…ƒç´ å€¼
	if (search != NULL)
	{
		printf("æŒ‰åºå·æŸ¥æ‰¾æˆåŠŸ\n");
		printf("%d\n", search->data);
	}
	
	search = LocateElem(L, 6);//æŒ‰å€¼æŸ¥è¯¢
	if (search != NULL)
	{
		printf("æŒ‰å€¼æŸ¥æ‰¾æˆåŠŸ\n");
		printf("%d\n", search->data);
	}
	ListFrontInsert(L, 2, 99);//æ–°ç»“ç‚¹æ’å…¥ç¬¬iä¸ªä½ç½®
	PrintList(L);
	ListDelete(L, 4);//åˆ é™¤ç¬¬å››ä¸ªç»“ç‚¹
	PrintList(L);
}
~~~

###### ğŸ¤©åŒå‘é“¾è¡¨

~~~c++
//åŒå‘é“¾è¡¨çš„å®šä¹‰
typedef struct DNode {   //åŒå‘é“¾è¡¨ç»“ç‚¹ç±»å‹
	ElemType data;       //æ•°æ®åŸŸ
	struct DNode* prior; //å‰é©±æŒ‡é’ˆ
	struct DNode* next;  //åç»§æŒ‡é’ˆ
}DNode,*DinkList;
~~~

~~~c++
#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
#include<stdlib.h>
typedef  int  ElemType;
typedef struct DNode {   //åŒå‘é“¾è¡¨ç»“ç‚¹ç±»å‹
	ElemType data;       //æ•°æ®åŸŸ
	struct DNode* prior; //å‰é©±æŒ‡é’ˆ
	struct DNode* next;  //åç»§æŒ‡é’ˆ
}DNode,*DLinkList;
//åŒå‘é“¾è¡¨å¤´æ’æ³•
DLinkList DList_head_insert(DLinkList& DL)
{
	DNode* s;
	int x;
	DL = (DLinkList)malloc(sizeof(DNode));//å¸¦å¤´ç»“ç‚¹çš„é“¾è¡¨
	DL->next = NULL;
	DL->prior = NULL;
	scanf("%d", &x);//3 4 5 6 7 9999
	while (x != 9999)
	{
		s = (DLinkList)malloc(sizeof(DNode));//ç”³è¯·ä¸€ä¸ªç©ºé—´ï¼Œå¼ºåˆ¶ç±»å‹è½¬æ¢
		s->data = x;
		s->next = DL->next;
		if (DL->next != NULL)//æ’å…¥ç¬¬ä¸€ä¸ªç»“ç‚¹æ—¶ï¼Œä¸éœ€è¦è¿™ä¸€æ­¥æ“ä½œ
		{
			DL->next->prior = s;
		}
		s->prior = DL;
		DL->next = s;
		scanf("%d", &x);
	}
	return DL;
}
//åŒå‘é“¾è¡¨å°¾æ’æ³•
DLinkList DList_tail_insert(DLinkList& DL)
{
	int x;
	DL = (DLinkList)malloc(sizeof(DNode));
	DNode* s, * r = DL;//rä»£è¡¨å°¾æŒ‡é’ˆ
	DL->prior = NULL;
	//3 4 5 6 7 9999
	scanf("%d", &x);
	while (x!=9999)
	{
		s = (DLinkList)malloc(sizeof(DNode));
		s->data = x;
		r->next = s;
		s->prior = r;
		r = s;//ræŒ‡å‘æ–°çš„è¡¨å°¾ç»“ç‚¹
		scanf("%d", &x);
	}
	r->next = NULL;//å°¾æŒ‡é’ˆçš„nextæŒ‡é’ˆèµ‹å€¼ä¸ºNULL
	return DL;
}
//é“¾è¡¨æ‰“å°
void PrintDList(DLinkList DL)
{
	DL = DL->next;
	while (DL != NULL)
	{
		printf("%3d", DL->data);
		DL = DL->next;
	}
	printf("\n");
}
DLinkList GetElem(DLinkList DL,int i)
{
	int j = 1;
	DNode* p = DL->next;
	if (0 == i)
	{
		return DL;
	}
	if (i < 1)
	{
		return NULL;
	}
	while (p && j < i)
	{
		p = p->next;
		j++;
	}
	return p;
}
bool DListFrontInsert(DLinkList DL, int i, ElemType e)
{
	DLinkList p = GetElem(DL, i - 1);//æ‰¾å‰ä¸€ä¸ªä½ç½®çš„åœ°å€
	if (NULL == p)
	{
		return false;
	}
	DLinkList s = (DLinkList)malloc(sizeof(DNode));//ä¸ºæ–°æ’å…¥çš„ç»“ç‚¹ç”³è¯·ç©ºé—´
	s->data = e;
	s->next = p->next;
	p->next->prior = s;
	s->prior = p;
	p->next = s;
	return true;
}
bool DListDelete(DLinkList DL, int i)
{
	DLinkList p = GetElem(DL, i - 1);
	if (NULL == p)
	{
		return false;
	}
	DLinkList q;
	q = p->next;
	if (q == NULL)//åˆ é™¤çš„å…ƒç´ ä¸å­˜åœ¨
	{
		return false;
	}
	p->next = q->next;//æ–­é“¾
	if (q->next != NULL)
	{
		q->next->prior = p;
	}
	free(q);//é‡Šæ”¾å¯¹åº”ç»“ç‚¹çš„ç©ºé—´
	return true;
}
int main()
{
	DLinkList DL;
	DLinkList search;
	DList_head_insert(DL);//å¤´éƒ¨æ’å…¥
	PrintDList(DL);
	DList_tail_insert(DL);//å°¾éƒ¨æ’å…¥
	PrintDList(DL);
	search = GetElem(DL, 2);
	if (search != NULL)
	{
		printf("æŒ‰åºå·æŸ¥æ‰¾æˆåŠŸ\n");
		printf("%d\n", search->data);
	}
	DListFrontInsert(DL, 3, 99);
	PrintDList(DL);
	DListDelete(DL, 3);
	PrintDList(DL);
	return 0;
}
~~~

###ğŸ˜Šæ ˆ

~~~c++
é¡ºåºå­˜å‚¨å®ç°æ ˆ
typedef struct {
	Elemtype data[50];
	int top;
}SqStack;
SqStack S;
~~~

~~~c++
#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
#include<stdlib.h>
#define MaxSize 50
typedef int Elemtype;
typedef struct {
	Elemtype data[MaxSize];//æ•°ç»„
	int top;
}SqStack;
void InitStack(SqStack &S)
{
	S.top = -1;//ä»£è¡¨æ ˆä¸ºç©º
}
bool StackEmpty(SqStack S)
{
	if (S.top == -1)
	{
		return true;
	}
	return false;
}
bool Push(SqStack& S, Elemtype x)
{
	if (S.top == MaxSize - 1)
	{
		return false;//æ ˆæ»¡
	}
	S.data[++S.top] = x;
	return true;//å…¥æ ˆæˆåŠŸ
}
//è·å–æ ˆé¡¶å…ƒç´ 
bool GetTop(SqStack S, Elemtype& x)
{
	if (StackEmpty(S))//æ ˆä¸ºç©º
	{
		return false;
	}
	x = S.data[S.top];
	return true;
}
bool Pop(SqStack& S, Elemtype& x)
{
	if (StackEmpty(S))//æ ˆä¸ºç©º
	{
		return false;
	}
	x = S.data[S.top];
	S.top--;
}
int main()
{

	SqStack S;
	bool flag;
	Elemtype m;//å­˜å‚¨æ‹¿å‡ºæ¥çš„æ ˆé¡¶å…ƒç´ 
	InitStack(S);//åˆå§‹åŒ–
	flag = StackEmpty(S);
	if (flag)
	{
		printf("æ ˆæ˜¯ç©ºçš„\n");
	}
	Push(S, 3);//å…¥æ ˆå…ƒç´ 3
	Push(S, 4);//å…¥æ ˆå…ƒç´ 4
	Push(S, 5);//å…¥æ ˆå…ƒç´ 5
	flag = GetTop(S, m);//è·å–æ ˆé¡¶å…ƒç´ ,ä½†æ˜¯S.topå€¼ä¸å˜
	if (flag)
	{
		printf("è·å–æ ˆé¡¶å…ƒç´ ä¸º%d\n", m);
	}
	flag = Pop(S, m);//å¼¹å‡ºæ ˆé¡¶å…ƒç´ 
	if (flag)
	{
		printf("å¼¹å‡ºçš„å…ƒç´ ä¸º%d\n",m);
	}
}
~~~

###âœŒï¸é˜Ÿåˆ—

#####ğŸ‘‘å¾ªç¯é˜Ÿåˆ—

~~~c++
#define MaxSize 5
typedef int Elemtype;
typedef struct {
	Elemtype data[MaxSize];//æ•°ç»„ï¼Œå­˜å‚¨MaxSize-1ä¸ªå…ƒç´ 
	int front, rear;//é˜Ÿåˆ—å¤´ï¼Œé˜Ÿåˆ—å°¾
}SqQueue;
SqQueue Q;
~~~

~~~c++
#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
#include<stdlib.h>
#define MaxSize 5
typedef int Elemtype;
typedef struct {
	Elemtype data[MaxSize];//æ•°ç»„ï¼Œå­˜å‚¨MaxSize-1ä¸ªå…ƒç´ 
	int front, rear;//é˜Ÿåˆ—å¤´ï¼Œé˜Ÿåˆ—å°¾
}SqQueue;
SqQueue Q;
void InitQueue(SqQueue& Q)
{
	Q.rear = Q.front = 0;
}
bool isEmpty(SqQueue& Q)
{
	if (Q.front == Q.rear)
	{
		return true;
	}
	return false;
}
bool EnQueue(SqQueue& Q, Elemtype x)
{
	if ((Q.rear + 1) % MaxSize == Q.front)
	{
		return false;//é˜Ÿåˆ—æ»¡äº†
	}
	Q.data[Q.rear] = x;
	Q.rear = (Q.rear + 1) % MaxSize;//å‘åç§»åŠ¨ä¸€æ ¼
	return true;
}
bool DeQueue(SqQueue& Q,Elemtype & x)
{
	if (Q.front == Q.rear)//é˜Ÿåˆ—ä¸ºç©º
	{
		return false;
	}
	x = Q.data[Q.front];
	Q.front = (Q.front + 1) % MaxSize;
	return true;
}
int main()
{
	SqQueue Q;
	bool ret;//å­˜å‚¨è¿”å›å€¼
	Elemtype element;//å­˜å‚¨å‡ºé˜Ÿå…ƒç´ 
	InitQueue(Q);//åˆå§‹åŒ–å¾ªç¯é˜Ÿåˆ—
	ret = isEmpty(Q);
	if (ret)
	{
		printf("é˜Ÿåˆ—ä¸ºç©º\n");
	}
	else {
		printf("é˜Ÿåˆ—ä¸ä¸ºç©º\n");
	}
	EnQueue(Q, 3);
	EnQueue(Q, 4);
	EnQueue(Q, 5);
	ret = EnQueue(Q, 6);
	ret = EnQueue(Q, 7);
	if (ret)
	{
		printf("å…¥é˜ŸæˆåŠŸ\n");
	}
	else {
		printf("å…¥é˜Ÿä¸æˆåŠŸ\n");
	}
	ret = DeQueue(Q, element);
	if (ret)
	{
		printf("å‡ºé˜ŸæˆåŠŸï¼Œå…ƒç´ å€¼ä¸º%d\n", element);
	}
	else {
		printf("å‡ºé˜Ÿå¤±è´¥");
	}
	ret = EnQueue(Q, 8);
	if (ret)
	{
		printf("å…¥é˜ŸæˆåŠŸ\n");
	}
	else {
		printf("å…¥é˜Ÿå¤±è´¥\n");
	}
}
~~~

#####ğŸ˜é˜Ÿåˆ—çš„é“¾å¼å­˜å‚¨

~~~c++
#include <stdio.h>
#include <stdlib.h>

typedef int ElemType;
typedef struct LinkNode{
	ElemType data;
	struct LinkNode *next;
}LinkNode;
typedef struct{
	LinkNode *front,*rear;//é“¾è¡¨å¤´ é“¾è¡¨å°¾
}LinkQueue;//å…ˆè¿›å…ˆå‡º

void InitQueue(LinkQueue &Q)
{
	Q.front=Q.rear=(LinkNode*)malloc(sizeof(LinkNode));//å¤´å’Œå°¾æŒ‡å‘åŒä¸€ä¸ªç»“ç‚¹
	Q.front->next=NULL;//å¤´ç»“ç‚¹çš„nextæŒ‡é’ˆä¸ºNULL
}

bool IsEmpty(LinkQueue Q)
{
	if(Q.front==Q.rear)
		return true;
	else
		return false;
}
//å…¥é˜Ÿï¼Œå°¾éƒ¨æ’å…¥æ³•
void EnQueue(LinkQueue &Q,ElemType x)
{
	LinkNode *s=(LinkNode *)malloc(sizeof(LinkNode));
	s->data=x;s->next=NULL;
	Q.rear->next=s;//rearå§‹ç»ˆæŒ‡å‘å°¾éƒ¨
	Q.rear=s;
}
//å‡ºé˜Ÿ  å¤´éƒ¨åˆ é™¤æ³•
bool DeQueue(LinkQueue &Q,ElemType &x)
{
	if(Q.front==Q.rear) return false;//é˜Ÿåˆ—ä¸ºç©º
	LinkNode *p=Q.front->next;//å¤´ç»“ç‚¹ä»€ä¹ˆéƒ½æ²¡å­˜ï¼Œæ‰€ä»¥å¤´ç»“ç‚¹çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹æ‰æœ‰æ•°æ®
	x=p->data;
	Q.front->next=p->next;//æ–­é“¾
	if(Q.rear==p)//åˆ é™¤çš„æ˜¯æœ€åä¸€ä¸ªå…ƒç´ 
		Q.rear=Q.front;//é˜Ÿåˆ—ç½®ä¸ºç©º
	free(p);
	return true;
}
//ã€Šç‹é“Cç£å­¦è¥ã€‹è¯¾ç¨‹
//ç‹é“è€ƒç ”æ•°æ®ç»“æ„ 3.2.3 é˜Ÿåˆ—çš„é“¾å¼å­˜å‚¨
//å¤´éƒ¨åˆ é™¤æ³•ï¼Œå°¾éƒ¨æ’å…¥æ³•
int main()
{
	LinkQueue Q;
	bool ret;
	ElemType element;//å­˜å‚¨å‡ºé˜Ÿå…ƒç´ 
	InitQueue(Q);//åˆå§‹åŒ–é˜Ÿåˆ—
	EnQueue(Q,3);
	EnQueue(Q,4);
	EnQueue(Q,5);
	EnQueue(Q,6);
	EnQueue(Q,7);
	ret=DeQueue(Q,element);
	if(ret)
	{
		printf("å‡ºé˜ŸæˆåŠŸ,å…ƒç´ å€¼ä¸º %d\n",element);
	}else{
		printf("å‡ºé˜Ÿå¤±è´¥\n");
	}
	system("pause");
}

~~~

###æ–æ³¢æ‹‰å¥‘æ•°åˆ—

~~~c++
#include <stdio.h>
#include <stdlib.h>
//Fibæ˜¯é€’å½’å‡½æ•°
int Fib(int n)
{
	if(n==0)
		return 0;
	else if(n==1)
		return 1;
	else
		return Fib(n-1)+Fib(n-2);
}
//ç‹é“æ•°æ®ç»“æ„ æ–æ³¢é‚£å¥‘æ•°åˆ—
//é€’å½’  å‡½æ•°è°ƒç”¨è‡ªèº«
//0  1  1  2  3   5 
//f(n)=f(n-1)+f(n-2)
//è€ƒç ”ä¸æ˜¯å¾ˆé‡è¦ï¼Œäº†è§£å³å¯

int main()
{
	int num;
	while(scanf("%d",&num)!=EOF)
	{
		printf("Fib(%d) = %d\n",num,Fib(num));
	}
	system("pause");
}
//é¢˜ç›®  nä¸ªå°é˜¶ï¼Œæ¯æ¬¡åªèƒ½ä¸Š1ä¸ªå°é˜¶ï¼Œæˆ–è€…2ä¸ªå°é˜¶ï¼Œnä¸ªå°é˜¶ï¼Œæœ‰å¤šå°‘ç§èµ°æ³•
~~~

###æ ‘

~~~c++
æ ‘èŠ‚ç‚¹çš„æ•°æ®ç»“æ„
typedef char BiElemType;
typedef struct BiTNode {
	BiElemType data;
	struct BiTNode* lchild;
	struct BiTNode* rchild;
}BiTNode,*BiTree;
~~~

~~~c++
//function.h
#include <stdio.h>
#include <stdlib.h>
//ä½œè€… ç‹é“è®­ç»ƒè¥ é¾™å“¥
typedef char BiElemType;
typedef struct BiTNode{
	BiElemType c;//cå°±æ˜¯ä¹¦ç±ä¸Šçš„data
	struct BiTNode *lchild;
	struct BiTNode *rchild;
}BiTNode,*BiTree;

typedef struct tag{
	BiTree p;//æ ‘çš„æŸä¸€ä¸ªç»“ç‚¹çš„åœ°å€å€¼
	struct tag *pnext;
}tag_t,*ptag_t;

//æ ˆçš„ç›¸å…³æ•°æ®ç»“æ„
#define MaxSize 50
typedef BiTree ElemType;
typedef struct{
	ElemType data[MaxSize];
	int top;
}SqStack;
void InitStack(SqStack &S);
bool StackEmpty(SqStack &S);
bool Push(SqStack &S,ElemType x);
bool Pop(SqStack &S,ElemType &x);
bool GetTop(SqStack &S,ElemType &x);
//é˜Ÿåˆ—çš„ç›¸å…³æ•°æ®ç»“æ„
typedef struct LinkNode{
	ElemType data;
	struct LinkNode *next;
}LinkNode;
typedef struct{
	LinkNode *front,*rear;
}LinkQueue;
void InitQueue(LinkQueue &Q);
bool IsEmpty(LinkQueue Q);
void EnQueue(LinkQueue &Q,ElemType x);
bool DeQueue(LinkQueue &Q,ElemType &x);

~~~

~~~c++
//stack.cpp
#include "function.h"
void InitStack(SqStack &S)
{
	S.top=-1;
}
bool StackEmpty(SqStack &S)
{
	if(S.top==-1)
		return true;
	else
		return false;
}
//å…¥æ ˆ
bool Push(SqStack &S,ElemType x)
{
	if(S.top==MaxSize-1)
	{
		return false;
	}
	S.data[++S.top]=x;
	return true;
}
//å‡ºæ ˆ
bool Pop(SqStack &S,ElemType &x)
{
	if(-1==S.top)
		return false;
	x=S.data[S.top--];
	return true;
}
//è¯»å–æ ˆé¡¶å…ƒç´ 
bool GetTop(SqStack &S,ElemType &x)
{
	if(-1==S.top)
		return false;
	x=S.data[S.top];
	return true;
}
~~~

~~~c++
//queue.cpp
#include "function.h"
//ä»£å¤´ç»“ç‚¹çš„é˜Ÿåˆ—
void InitQueue(LinkQueue &Q)
{
	Q.front=Q.rear=(LinkNode*)malloc(sizeof(LinkNode));
	Q.front->next=NULL;
}

bool IsEmpty(LinkQueue Q)
{
	if(Q.front==Q.rear)
		return true;
	else
		return false;
}

void EnQueue(LinkQueue &Q,ElemType x)
{
	LinkNode *s=(LinkNode *)malloc(sizeof(LinkNode));
	s->data=x;s->next=NULL;
	Q.rear->next=s;
	Q.rear=s;
}

bool DeQueue(LinkQueue &Q,ElemType &x)
{
	if(Q.front==Q.rear) return false;
	LinkNode *p=Q.front->next;//å¤´ç»“ç‚¹ä»€ä¹ˆéƒ½æ²¡å­˜ï¼Œæ‰€ä»¥å¤´ç»“ç‚¹çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹æ‰æœ‰æ•°æ®
	x=p->data;
	Q.front->next=p->next;
	if(Q.rear==p)
		Q.rear=Q.front;
	free(p);
	return true;
}
~~~

~~~c++
//main.cpp
#include "function.h"

//é€’å½’å®ç°
//abdhiejcfg
void preOrder(BiTree p)
{
	if(p!=NULL)
	{
		putchar(p->c);//ç­‰ä»·äºvisitå‡½æ•°
		preOrder(p->lchild);
		preOrder(p->rchild);
	}
}
//ä¸­åºéå†  hdibjeafcg
void InOrder(BiTree p)
{
	if(p!=NULL)
	{
		InOrder(p->lchild);
		putchar(p->c);
		InOrder(p->rchild);
	}
}
//hidjebfgca
void PostOrder(BiTree p)
{
	if(p!=NULL)
	{
		PostOrder(p->lchild);
		PostOrder(p->rchild);
		putchar(p->c);
	}
}
//ä¸­åºéå†éé€’å½’ï¼Œéé€’å½’æ‰§è¡Œæ•ˆç‡æ›´é«˜ï¼Œè€ƒçš„æ¦‚ç‡å¾ˆä½
void InOrder2(BiTree T)
{
	SqStack S;
	InitStack(S);BiTree p=T;
	while(p||!StackEmpty(S))//é€»è¾‘æˆ–||
	{
		if(p)
		{
			Push(S,p);
			p=p->lchild;
		}else{
			Pop(S,p);putchar(p->c);
			p=p->rchild;
		}
	}
}
//å±‚æ¬¡éå†,å¹¿åº¦ä¼˜å…ˆéå†
void LevelOrder(BiTree T)
{
	LinkQueue Q;
	InitQueue(Q);
	BiTree p;
	EnQueue(Q,T);//æ ‘æ ¹å…¥é˜Ÿ
	while(!IsEmpty(Q))
	{
		DeQueue(Q,p);
		putchar(p->c);
		if(p->lchild!=NULL)
			EnQueue(Q,p->lchild);
		if(p->rchild!=NULL)
			EnQueue(Q,p->rchild);
	}
}
//ã€Šç‹é“Cç£å­¦è¥ã€‹è¯¾ç¨‹
//äºŒå‰æ ‘çš„å»ºæ ‘ï¼ˆå±‚æ¬¡å»ºæ ‘ï¼‰ï¼Œå‰åºã€ä¸­åºã€ååºéå†ã€ä¸­åºéé€’å½’éå†ã€å±‚æ¬¡éå†
int main()
{
	BiTree pnew;
	int i,j,pos;
	char c;
	BiTree tree=NULL;//æ ‘æ ¹
	ptag_t phead=NULL,ptail=NULL,listpnew,pcur;//pheadå°±æ˜¯é˜Ÿåˆ—å¤´ï¼Œptailå°±æ˜¯é˜Ÿåˆ—å°¾
	//abcdefghij
	while(scanf("%c",&c)!=EOF)
	{
		if(c=='\n')
		{
			break;
		}
		pnew=(BiTree)calloc(1,sizeof(BiTNode));//callocç”³è¯·ç©ºé—´å¹¶å¯¹ç©ºé—´è¿›è¡Œåˆå§‹åŒ–ï¼Œèµ‹å€¼ä¸º0
		pnew->c=c;//æ•°æ®æ”¾è¿›å»
		listpnew=(ptag_t)calloc(1,sizeof(tag_t));//ç»™é˜Ÿåˆ—ç»“ç‚¹ç”³è¯·ç©ºé—´
		listpnew->p=pnew;
		if(NULL==tree)
		{
			tree=pnew;//æ ‘çš„æ ¹
			phead=listpnew;//é˜Ÿåˆ—å¤´
			ptail=listpnew;//é˜Ÿåˆ—å°¾
			pcur=listpnew;
			continue;
		}else{
			ptail->pnext=listpnew;//æ–°ç»“ç‚¹æ”¾å…¥é“¾è¡¨ï¼Œé€šè¿‡å°¾æ’æ³•
			ptail=listpnew;//ptailæŒ‡å‘é˜Ÿåˆ—å°¾éƒ¨
		}//pcurå§‹ç»ˆæŒ‡å‘è¦æ’å…¥çš„ç»“ç‚¹çš„ä½ç½®
		if(NULL==pcur->p->lchild)//å¦‚ä½•æŠŠæ–°ç»“ç‚¹æ”¾å…¥æ ‘
		{
			pcur->p->lchild=pnew;//æŠŠæ–°ç»“ç‚¹æ”¾åˆ°è¦æ’å…¥ç»“ç‚¹çš„å·¦è¾¹
		}else if(NULL==pcur->p->rchild)
		{
			pcur->p->rchild=pnew;//æŠŠæ–°ç»“ç‚¹æ”¾åˆ°è¦æ’å…¥ç»“ç‚¹çš„å³è¾¹
			pcur=pcur->pnext;//å·¦å³éƒ½æ”¾äº†ç»“ç‚¹åï¼ŒpcuræŒ‡å‘é˜Ÿåˆ—çš„ä¸‹ä¸€ä¸ª
		}
	}
	printf("--------å‰åºéå†----------\n");
	preOrder(tree);
	printf("\n--------ä¸­åºéå†------------\n");
	InOrder(tree);
	printf("\n--------ååºéå†------------\n");
	PostOrder(tree);
	printf("\n--------ä¸­åºéå†éé€’å½’------\n");//é‡è¦æ€§ä½
	InOrder2(tree); 
	printf("\n--------å±‚æ¬¡éå†-----------\n");
	LevelOrder(tree);
	printf("\n");
	system("pause");
} 
~~~

###æŸ¥æ‰¾

~~~
~~~

